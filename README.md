# Application-2


Engineering Analysis (Discussion 
Task Timing and Jitter: Compare the timing of the LED blink and console print tasks with that of the sensor task. How regular is each task’s period in practice? Highly regular. Sensor alert messages ( "Eclipse Warning: Avg Solar Lux = ") appear every 500 ms consistently.
 For the sensor task (using vTaskDelayUntil), do the sensor readings and alert messages occur at consistent intervals (e.g. every 500 ms)? Because vTaskDelayUntil(&lastWakeTime, periodTicks) calculates the next absolute wake-up time by adding a fixed offset (periodTicks) to lastWakeTime (not to the current tick count). This guarantees that each wake-up is exactly 500 ms apart, regardless of how long the task execution takes—as long as it completes within that 500 ms window.


 In contrast, do you observe any drift or variation in the LED blink or print intervals over time? No Jitter even if execution varies slightly, timing realigns automatically on the next cycle.




Explain why vTaskDelayUntil provides a more stable period for the sensor task, referencing how it calculates the next wake-up tick based on an absolute time reference. What might cause jitter in the LED or print task periods when using vTaskDelay? (Hint: consider the effect of the sensor task running at the moment they are ready to run, and how that might delay them slightly.) 
vTaskDelayUntil() ensures stable, precise task timing by using an absolute time reference for delays, preventing drift even if task execution varies. In contrast, vTaskDelay() uses a relative delay, so timing can drift over time due to preemption or execution delays, causing jitter—especially when higher-priority tasks (like the sensor task) run first.


Priority-Based Preemption: Describe a scenario observed in your running system that demonstrates FreeRTOS’s priority-based preemptive scheduling. For example, what happens if the console print task is about to print (or even mid-way through printing) exactly when the sensor task’s next period arrives? 
In the running system, a scenario that demonstrates FreeRTOS’s priority-based preemptive scheduling occurs when the console print task (low priority) is printing its heartbeat message and, at that exact moment, the high-priority sensor task reaches its scheduled period and becomes ready to execute. In the simulation output, this is evident when a sensor reading appears before the print task completes its cycle, even though the print was expected around the same time. This behavior confirms that FreeRTOS preempted the lower-priority print task in favor of the higher-priority sensor task.
Does the sensor task interrupt the print task immediately, or does it wait?
When the sensor task becomes ready (unblocks) and the console print task is currently running or about to run, the sensor task immediately interrupts the print task. 
 Based on your understanding of FreeRTOS, which task would the scheduler choose to run at a moment when both become Ready, and why?
Based on my understanding of FreeRTOS, when two tasks become Ready at the same time, the scheduler will choose to run the task with the highest priority. In this system, the sensor task has a priority of 3, the LED task has priority 2, and the print task has priority 1. Therefore, if the sensor and print tasks become Ready at the same tick, the scheduler will select the sensor task to run first because it has a higher priority than the print task.
 Provide a brief timeline or example (using tick counts or event ordering) to illustrate the preemption. (If you didn’t explicitly catch this in simulation, answer conceptually: assume the print task was running right when the sensor task unblocked – what should happen?)
A conceptual example of preemption could be as follows: At tick 5000, the console print task is executing and outputting a heartbeat message. At the same tick, the sensor task becomes ready due to its scheduled 500 ms delay expiring. Since the sensor task has a higher priority, FreeRTOS preempts the print task immediately and switches execution to the sensor task. The sensor task completes its lux measurement and moves to a blocked state using vTaskDelayUntil. Then, FreeRTOS resumes the print task from where it left off. This shows how the sensor task interrupts the print task to maintain precise timing and demonstrates true preemptive scheduling.
Effect of Task Execution Time: In our design, all tasks have small execution times (they do minimal work before blocking again). Suppose the sensor task took significantly longer to execute (for instance, imagine it performed a complex calculation taking, say, 300 ms of CPU time per cycle). How would that affect the lower-priority tasks?
If the sensor task takes significantly longer to execute—such as 300 ms of CPU time each cycle—this increased execution time can delay the scheduling of lower-priority tasks like the LED blink and console print tasks. Since FreeRTOS uses priority-based preemptive scheduling, the high-priority sensor task dominates the CPU while it is ready and running, causing lower-priority tasks to wait longer before getting CPU time. 


 Discuss what would happen if the sensor task’s execution time sometimes exceeds its period (i.e., it can’t finish its work before the next 500 ms tick). What symptoms would you expect to see in the system (e.g. missed readings, delayed LED toggles, etc.)?
If the sensor task’s execution time occasionally exceeds its 500 ms period (e.g., taking 600 ms), the task would miss its intended start time for the next sampling cycle. This leads to missed readings and potentially back-to-back executions that further starve other tasks. In the system, this could show up as delayed or skipped LED toggles, erratic or clumped sensor print outputs, and inconsistent timing of heartbeat (telemetry) messages. Symptoms of such overload include jitter in the LED blink rate, irregular heartbeat counts in the serial console, and possible gaps or irregularity in sensor readings.


 Relate this to real-time scheduling concepts like missed deadlines or CPU utilization from the RTOS theory (Chapters 3 and 6 of the Harder textbook). What options could a system designer consider if the high-priority task started starving lower tasks or missing its schedule (think about reducing workload, adjusting priorities, or using two cores)?
This situation is an example of a missed deadline, where a periodic task (the sensor) fails to complete before its next activation time. It also raises concerns about CPU utilization, as the total execution load may exceed what the processor can handle within fixed time windows. According to RTOS theory ( the Harder textbook), a task set is schedulable if the CPU utilization remains under a certain threshold exceeding this risks instability and unresponsiveness.


vTaskDelay vs vTaskDelayUntil: Why did we choose vTaskDelayUntil for the sensor task instead of using vTaskDelay in a simple loop? Explain in your own words the difference between these two delay functions in FreeRTOS, and the specific problem that vTaskDelayUntil solves for periodic real-time tasks. Consider what could happen to the sensor sampling timing over many iterations if we used vTaskDelay(500 ms) instead – how might small errors accumulate?
We use vTaskDelayUntil for the sensor task because it ensures a fixed and consistent sampling interval by referencing an absolute tick count, not a relative delay. In contrast, vTaskDelay pauses for a fixed time relative to the end of the previous task execution, meaning if the task runs longer than expected or gets preempted, the next execution will be pushed later. This leads to timing drift, where small variations accumulate over many cycles, causing the sensor to run at inconsistent or increasingly delayed intervals. In real-time systems, especially for periodic tasks like sensor sampling, maintaining a steady execution rate is critical for data accuracy and timing predictability, which vTaskDelayUntil effectively guarantees
 Also, for the LED blink task, why is using vTaskDelay acceptable in that context? (Think about the consequences of slight timing drift for a status LED vs. a sensor sampling task.)
Using vTaskDelay for the LED blink task is acceptable because precise timing is not critical for a status LED. The LED serves mainly as a visual heartbeat or indicator, so a small drift in the blink interval (for example, blinking at 502 ms instead of 500 ms) will not impact system correctness or user perception. Since the LED blink task is not time-sensitive and doesn't require a strict sampling or event schedule, vTaskDelay offers a simpler and sufficient method of implementing periodic blinking.


Thematic Integration Reflection: Relate the functioning of your three tasks to a real-world scenario in one of the thematic contexts (Space Systems, Healthcare, or Hardware Security). Describe an example of what each task could represent. Explain how task priority might reflect the importance of that function in the real system (e.g. why the sensor monitoring is high priority in a medical device).
In a space system, the sensor task represents solar monitoring and is given the highest priority because accurate light detection is critical for power and safety. The LED blink task acts as a system status beacon with medium priority, since visual indicators are helpful but not urgent. The console print task simulates telemetry reporting and has the lowest priority, as occasional delays in logs are acceptable. Task priorities reflect real-world importance, ensuring that critical monitoring runs reliably while less essential tasks run only when resources are available.


Bonus - design an experiment which causes starvation in the system (e.g., sensor task never gives time to the other tasks). Describe the code you used and the results. Leave the code in your environment but comment it out. Return your code for submission to a working ideal state.
To demonstrate task starvation, I modified the sensor_task() by commenting out the vTaskDelayUntil() call at the end of its loop. This caused the sensor task, which has the highest priority, to run continuously without ever yielding control to the lower-priority tasks. As a result, the LED blink task and the console print task were completely starved and never got CPU time to execute. In the simulation output, only the sensor's LUX readings appeared rapidly, while the LED stopped blinking and the telemetry messages ceased, confirming that starvation occurred due to the unblocked high-priority task.

